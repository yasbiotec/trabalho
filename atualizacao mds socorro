#include "raylib.h"
#include <stdio.h>
#include <stdlib.h>

#define COBRA_TAMANHO    100 // Máximo do tamanho da cobra
#define CEDULAS          25 // Tamanho das células
#define ALTURA           800
#define LARGURA          800
#define TAM_FONTE        25

// Tipos e estruturas do jogo
typedef struct Snake {
    Vector2 posicao;
    Vector2 tamanho;
    Vector2 speed;
    Color color;
} Snake;

typedef struct Food {
    Vector2 posicao;
    Vector2 tamanho;
    bool active;
    bool special;
    Color color;
} Food;

// Variáveis globais
static int framesCounter = 0;
static bool gameOver = false;
static bool pause = false;
static Food fruit = { 0 };
static Snake snake[COBRA_TAMANHO] = { 0 };
static Vector2 snakePosition[COBRA_TAMANHO] = { 0 };
static bool allowMove = false;
static Vector2 offset = { 0 };
static int counterTail = 0;
static int pontos = 0;
static int recorde = 0;
int opcao = 0;
int mapaLargura = 0;
int mapaAltura = 0;
char **mapa;

// Declaração de funções locais
static void InitGame(void);
static void UpdateGame(void);
static void DrawGame(void);
static void UpdateDrawFrame(void);
static void MostrarPontuacoes(void);
static int Menu(void);
static void CarregarMapa(const char *nomeArquivo);
static void DesenharMapa(void);
static bool VerificarColisaoComBarreira(Vector2 posicao);
static void GerarFruta(void);
#define MAPA1 "C:/Users/yasmi/Downloads/Trabalho final/mapa_1.txt"
#define MAPA2
#define MAPA3
#define MAPA4

// Função principal do jogo
int main(void)
{
    InitWindow(LARGURA, ALTURA, "Trabalho final: Snake");
    SetTargetFPS(60);

    CarregarMapa(MAPA1);  // Carregar o mapa

    while (!WindowShouldClose())
    {
        int estadoJogo = Menu();

        if (estadoJogo == 1)  // Jogar
        {
            InitGame();
            while (!WindowShouldClose() && !gameOver)
            {
                UpdateDrawFrame();
            }

            gameOver = false;
        }
        else if (estadoJogo == 2)  // Mostrar pontuações
        {
            MostrarPontuacoes();
        }
        else if (estadoJogo == 3)  // Sair
        {
            break;
        }
    }
    CloseWindow();

    // Liberar memória do mapa
    for (int i = 0; i < mapaAltura; i++)
        free(mapa[i]);
    free(mapa);

    return 0;
}

// Função para carregar o mapa do arquivo
void CarregarMapa(const char *nomeArquivo)
{
    FILE *arquivo = fopen(nomeArquivo, "r");
    if (arquivo == NULL)
    {
        printf("Erro ao abrir o arquivo do mapa!\n");
        exit(1);
    }

    fscanf(arquivo, "%d %d", &mapaLargura, &mapaAltura);
    int numItens;
    fscanf(arquivo, "%d", &numItens);

    mapa = (char **)malloc(mapaAltura * sizeof(char *));
    for (int i = 0; i < mapaAltura; i++)
        mapa[i] = (char *)malloc((mapaLargura + 1) * sizeof(char));

    for (int i = 0; i < mapaAltura; i++)
        fgets(mapa[i], mapaLargura + 1, arquivo);

    fclose(arquivo);
}

// Função para desenhar o mapa
void DesenharMapa(void)
{
    for (int y = 0; y < mapaAltura; y++)
    {
        for (int x = 0; x < mapaLargura; x++)
        {
            if (mapa[y][x] == '#')
                DrawRectangle(x * CEDULAS, y * CEDULAS, CEDULAS, CEDULAS, DARKGRAY);
        }
    }
}

// Função para verificar colisão com barreiras
// Função para verificar colisão com barreiras
bool VerificarColisaoComBarreira(Vector2 posicao)
{
    int x = posicao.x / CEDULAS;
    int y = posicao.y / CEDULAS;

    // Verifica se a posição está fora dos limites do mapa
    if (x < 0 || x >= mapaLargura || y < 0 || y >= mapaAltura)
        return true;

    return (mapa[y][x] == '#');
}

// Função para gerar a fruta em uma posição válida
void GerarFruta(void)
{
    bool posicaoValida = false;
    float numerpegoX;
    float numerpegoY;

    while (!posicaoValida)
    {
        numerpegoX = GetRandomValue(1, mapaLargura - 2) * CEDULAS;  // Evita a borda do mapa
        printf("x: %f\n", &numerpegoX);
        numerpegoY = GetRandomValue(1, mapaAltura - 2) * CEDULAS;   // Evita a borda do mapa
        printf("y: %f\n", &numerpegoY);
        fruit.posicao = (Vector2){
            numerpegoX, numerpegoY
            /*
            GetRandomValue(1, mapaLargura - 2) * CEDULAS,  // Evita a borda do mapa
            GetRandomValue(1, mapaAltura - 2) * CEDULAS   // Evita a borda do mapa
            */
        };
        //printf("posicao da fruta: %f,%f\n", &fruit.posicao.x, &fruit.posicao.y);

        if (!VerificarColisaoComBarreira(fruit.posicao))
        {
            posicaoValida = true;
            fruit.special = GetRandomValue(0, 2) == 0; // 33% chance de ser especial
            fruit.color = fruit.special ? RED : SKYBLUE;
            fruit.active = true;  // Certifique-se de marcar a fruta como ativa
        }
    }
    //printf("posicao da fruta: %f,%f\n", &fruit.posicao.x, &fruit.posicao.y);
}

// Função para inicializar o jogo
void InitGame(void)
{
    framesCounter = 0;
    gameOver = false;
    pause = false;

    counterTail = 1;
    allowMove = false;

    offset.x = 0;
    offset.y = 0;

    for (int i = 0; i < COBRA_TAMANHO; i++)
    {
        snake[i].posicao = (Vector2){ LARGURA / 2, ALTURA / 2 };
        snake[i].tamanho = (Vector2){ CEDULAS, CEDULAS };
        snake[i].speed = (Vector2){ CEDULAS, 0 };

        if (i == 0) snake[i].color = DARKBLUE;
        else snake[i].color = BLUE;
    }

    fruit.tamanho = (Vector2){ CEDULAS, CEDULAS };
    fruit.active = false;

    GerarFruta(); // Inicializa a fruta
}


// Função para atualizar o jogo
void UpdateGame(void)
{
    if (!gameOver)
    {
        if (IsKeyPressed(KEY_TAB)) pause = !pause;

        if (!pause)
        {
            // Controle do jogador
            if ((IsKeyPressed(KEY_RIGHT) || IsKeyPressed(KEY_D)) && (snake[0].speed.x == 0) && allowMove)
            {
                snake[0].speed = (Vector2){ CEDULAS, 0 };
                allowMove = false;
            }
            if ((IsKeyPressed(KEY_LEFT) || IsKeyPressed(KEY_A)) && (snake[0].speed.x == 0) && allowMove)
            {
                snake[0].speed = (Vector2){ -CEDULAS, 0 };
                allowMove = false;
            }
            if ((IsKeyPressed(KEY_UP) || IsKeyPressed(KEY_W)) && (snake[0].speed.y == 0) && allowMove)
            {
                snake[0].speed = (Vector2){ 0, -CEDULAS };
                allowMove = false;
            }
            if ((IsKeyPressed(KEY_DOWN) || IsKeyPressed(KEY_S)) && (snake[0].speed.y == 0) && allowMove)
            {
                snake[0].speed = (Vector2){ 0, CEDULAS };
                allowMove = false;
            }

            // Movimento da cobra
            for (int i = 0; i < counterTail; i++) snakePosition[i] = snake[i].posicao;

            if ((framesCounter % 5) == 0)
            {
                Vector2 novaPosicao = (Vector2){
                    snake[0].posicao.x + snake[0].speed.x,
                    snake[0].posicao.y + snake[0].speed.y
                };

                // Verificar se a nova posição é uma barreira
                if (VerificarColisaoComBarreira(novaPosicao))
                {
                    gameOver = true; // Morrer ao tocar a barreira
                }
                else
                {
                    snake[0].posicao = novaPosicao;

                    // Atualizar o corpo da cobra
                    for (int i = 1; i < counterTail; i++)
                    {
                        snake[i].posicao = snakePosition[i - 1];
                    }

                    allowMove = true;
                }
            }

            // Colisão com si mesmo
            for (int i = 1; i < counterTail; i++)
            {
                if ((snake[0].posicao.x == snake[i].posicao.x) && (snake[0].posicao.y == snake[i].posicao.y))
                {
                    gameOver = true;
                }
            }

            // Atualizar posição da fruta
            if (!fruit.active)
            {
                GerarFruta();
            }

            // Colisão com a fruta
            if ((snake[0].posicao.x < (fruit.posicao.x + fruit.tamanho.x) &&
                (snake[0].posicao.x + snake[0].tamanho.x) > fruit.posicao.x) &&
                (snake[0].posicao.y < (fruit.posicao.y + fruit.tamanho.y) &&
                (snake[0].posicao.y + snake[0].tamanho.y) > fruit.posicao.y))
            {
                if (fruit.special)
                {
                    // Determina o efeito da fruta especial
                    fruit.color = RED;
                    pontos += 15;
                    int effect = GetRandomValue(0, 2);

                    if (effect == 0)
                    {
                        // Aumenta a velocidade
                        if (framesCounter > 2) framesCounter -= 2;
                    }
                    else if (effect == 1)
                    {
                        // Diminui a velocidade
                        if (framesCounter < 20) framesCounter += 2;
                    }
                    else if (effect == 2)
                    {
                        // Reduz o tamanho
                        if (counterTail > 1) counterTail--;
                    }
                }
                else
                {
                    // Comportamento da fruta normal
                    if (counterTail < COBRA_TAMANHO) {
                        snake[counterTail].posicao = snakePosition[counterTail - 1];
                        counterTail++;
                    }
                    fruit.color = SKYBLUE;
                }

                fruit.active = false;
                pontos += 10;
            }

            framesCounter++;
        }
    }
    else
    {
        if (IsKeyPressed(KEY_ENTER))
        {
            InitGame();
            gameOver = false;
        }
    }
}

// Função para desenhar o jogo
void DrawGame(void)
{
    BeginDrawing();
    ClearBackground(RAYWHITE);

    // Desenhar o mapa
    DesenharMapa();

    // Desenhar a cobra
    for (int i = 0; i < counterTail; i++)
    {
        DrawRectangleV(snake[i].posicao, snake[i].tamanho, snake[i].color);
    }

    // Desenhar a fruta
    if (fruit.active)  // Só desenha a fruta se estiver ativa
    {
        DrawRectangleV(fruit.posicao, fruit.tamanho, fruit.color);
    }

    if (pause)
    {
        DrawText("GAME PAUSED", LARGURA / 2 - MeasureText("GAME PAUSED", 40) / 2, ALTURA / 2 - 40, 40, GRAY);
        DrawText(TextFormat("PONTOS: %d", pontos), LARGURA / 2 - MeasureText(TextFormat("PONTOS: %d", pontos), 20) / 2, ALTURA / 2, 20, GRAY);
    }
    else if (gameOver)
    {
        DrawText("PRESS [ENTER] TO PLAY AGAIN", GetScreenWidth() / 2 - MeasureText("PRESS [ENTER] TO PLAY AGAIN", 20) / 2, GetScreenHeight() / 2 - 50, 20, GRAY);
        if (pontos > recorde)
        {
            recorde = pontos;
            pontos = 0;
        }
        DrawText(TextFormat("RECORDE: %d", recorde), LARGURA / 2 - MeasureText(TextFormat("RECORDE: %d", recorde), 20) / 2, ALTURA / 2, 20, GRAY);
    }

    EndDrawing();
}

// Função para atualizar e desenhar um frame
void UpdateDrawFrame(void)
{
    UpdateGame();
    DrawGame();
}

// Função do Menu
int Menu(void)
{
    while (!WindowShouldClose())
    {
        BeginDrawing();
        ClearBackground(RAYWHITE);

        DrawText("Jogar", LARGURA / 2, ALTURA / 4, TAM_FONTE, BLACK);
        DrawText("Score", LARGURA / 2, ALTURA / 4 + 50, TAM_FONTE, BLACK);
        DrawText("Sair", LARGURA / 2, ALTURA / 4 + 100, TAM_FONTE, BLACK);

        switch (opcao)
        {
            case 0:
                DrawRectangleLines(LARGURA / 2 - 10, ALTURA / 4 - 5, 100, 30, RED);
                break;
            case 1:
                DrawRectangleLines(LARGURA / 2 - 10, ALTURA / 4 + 50 - 5, 100, 30, RED);
                break;
            case 2:
                DrawRectangleLines(LARGURA / 2 - 10, ALTURA / 4 + 100 - 5, 100, 30, RED);
                break;
        }

        EndDrawing();

        if (IsKeyPressed(KEY_UP))
        {
            opcao--;
            if (opcao < 0) opcao = 2;
        }
        else if (IsKeyPressed(KEY_DOWN))
        {
            opcao++;
            if (opcao > 2) opcao = 0;
        }
        else if (IsKeyPressed(KEY_ENTER))
        {
            return opcao + 1;  // 1 = Jogar, 2 = Score, 3 = Sair
        }
    }

    return 3;  // Se a janela for fechada, retorna para a opção de sair
}

// Função para mostrar as pontuações
void MostrarPontuacoes(void)
{
    while (!WindowShouldClose())
    {
        BeginDrawing();
        ClearBackground(RAYWHITE);
        DrawText("Score", LARGURA / 2 - MeasureText("Score", TAM_FONTE) / 2, ALTURA / 4, TAM_FONTE, BLACK);
        DrawText(TextFormat("Recorde: %d", recorde), LARGURA / 2 - MeasureText(TextFormat("Recorde: %d", recorde), TAM_FONTE) / 2, ALTURA / 4 + 50, TAM_FONTE, BLACK);
        DrawText("Pressione [ENTER] para voltar", LARGURA / 2 - MeasureText("Pressione [ENTER] para voltar", 20) / 2, ALTURA / 4 + 100, 20, GRAY);
        EndDrawing();

        if (IsKeyPressed(KEY_ENTER) || IsKeyPressed(KEY_ESCAPE))
        {
            break;  // Volta ao menu
        }
    }
}

